为了进行简单的模拟，基于Ext2的思想和算法，设计一个类Ext2的文件系统，实现Ext2文件系统的一个功能子集。**并且用现有操作系统上的文件来代替硬盘进行硬件模拟。**

设计文件系统应该考虑的几个层次

+ 介质的物理结构

+ 物理操作——设备驱动程序完成

+ ==文件系统的组织结构（逻辑组织结构）==

+ ==对组织结构其上的操作==

+ ==为用户使用文件系统提供的接口==

## 文件系统的基本实现

**数据结构及其磁盘布局**

文件的存储：如何帮助用户找到磁盘中存储的文件？如何防止用户非法访问另一个用户的文件？如何知道磁盘被使用的情况？

整体布局、超级块、文件的索引、目录的存储、空闲块管理、块组描述符

**文件的基本操作**

接口和用户界面设计、节点创建删除设计、节点操作设计

![image-20231123164049339](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20231123164049339.png)

## 类ext2文件系统的数据结构

### 1.块的定义

逻辑块和物理块的大小均定义为512字节。

由于位图（inode位图和逻辑块位图）只占一个块，因此每个组的数据块个数以及索引结点的个数均确定为8*512=4096。进一步，每组的数据容量确定为4096\*512B=2MB。

### 2.组描述符

为简单起见。只定义一个组，因此组描述符只占用一个块；省略superblock块，其功能由组描述符块代替，即组描述符块中需要增加文件系统大小、索引结点的大小，卷名。

具体数据结构为

```c
struct ext2_group_desc {       
    char 	bg_volume_name[16];  	//卷名	16B
    _u16   	bg_block_bitmap;       	//保存块位图的块号		2B
    _u16   	bg_inode_bitmap;     	//保存索引结点位图的块号	2B	
    _u16   	bg_inode_table;     	//索引结点表的起始块号	2B
    _u16   	bg_free_blocks_count;   //本组空闲块的个数	2B
    _u16   	bg_free_inodes_count;   //本组空闲索引结点的个数	2B
    _u16   	bg_used_dirs_count;	    //本组目录的个数	2B
    char    psw[16];			   //密码 	16B
    char 	bg_pad[4]; 	            //填充(0xff)
};
```

### 3.索引结点

容量已经确定，文件最大为2MB。需要4096个数据块。所以只需要13个二进制位即可对块进行全局计数，实现用unsigned int 16位变量，即2字节表示一个块号。

采用多级索引机制。经过计算发现，只使用二级指针就可以满足要求了。

> 在一级子索引中，如果一个数据块都用来存放块号，则可以存放512/2＝256个。因此，只使用一级子索引可以容纳最大的文件为256\*512=128KB。需要使用二级子索引。只使用二级子索引时，索引结点中的一个指针可以指向256\*256个块，即256\*256\*512=32MB，已经可以满足要求了。

简单起见，索引结点的直接索引（直接指向数据块）定义6个，一级子索引（指向存放数据块指针的块）1个，二级子索引1个。

具体数据结构为

```c
 struct ext2_inode {        
    _u16   	i_mode;     //文件类型及访问权限		
    _u16  	i_blocks; 	//文件的数据块个数		
    _u32  	i_size;     //大小(字节)		
    _u32    fd;			//				
    time_t 	i_atime;   	//访问时间		
    time_t 	i_ctime;   	//创建时间
    time_t 	i_mtime;   	//修改时间
    time_t 	i_dtime;    //删除时间
    _u16	i_block[8];	//指向数据块的指针	
 };
```

**对i_mode的解释：**

高八位(high_i_mode)是目录项中文件类型码的一个拷贝；低八位(low_i_mode)中最低三位用来标识rwx3个属性。高五位不用，用0填充。在显示访问权限时，所有者、组、全局均使用低三位的标识。这样可生成一个文件的完整的drwxrwxrwx描述。

特别的，在模拟系统中，凡是扩展名为.exe,.bin,.com及不带扩展名的，都被加上x标识。（而在Unix中，不带扩展名的文件为可执行文件）

**i_block域与文件大小以及数据块的关系：**

![image-20231123181412593](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20231123181412593.png)

+ ⑴当文件长度小于等于512*6=3072字节（3KB）时，只用到直接索引
+ ⑵当文件长度大于3072字节，并且小于等于3KB+128KB即131KB时，除使用直接索引处，还将使用一级子索引。
+ ⑶当文件长度大于131KB，并且小于2MB（文件系统最大值）时，将开始使用二级子索引。

### 4.文件系统的数据容量 

假设仅保存一个大文件，现在来计算这个文件最多能有多大。由于索引结点表本身要占用数据块，文件最大长度并没有2MB。文件系统初始化时，根目录用去一个数据块。当文件大于131KB时，一级子索引本身还要占用一个数据块512字节。即，已经用去131KB+0.5KB(根目录)+0.5KB(索引数据块)=132KB的空间。此外，由于文件系统的限制，二级子索引并不会全部使用。这里定义二级子索引的使用顺序是深度优先。即，必须先使用完第1个二级子索引512\*256=128KB后，再使用第2个二级子索引。这样，每使用一个2级索引，多占用1个数据块，512字节。假设使用了n(<256)个二级子索引，占用的空间大小为(1+n)\*512=(1+n)/2KB。加上已经使用的132KB的空间，总共使用了的容量为132+128\*n+(1+n)/2　KB。令其等于文件系统的容量，2MB，解方程: 132+128\*n+(1+n)/2=2048　得n=14.91。即最多只能使用满14个二级子索引，最多可以使用到15个二级子索引。由上可得，对一个文件，实际中子索引系统所占用的数据块最多为1+1+15=17个。加上根目录，总共用了18个数据块来存放文件系统的信息。当14个二级子索引全部使用满时，用来存储文件数据的数据块最为6+256+14\*256=3846个。当使用第15个二级子索引时，又用1个数据块来存放索引结点。文件系统总计有4096个数据块。那么留下给第15个二级子索引使用的数据块为4096-18-3846=232。这是第15个二级子索引的索引结点数的上限。文件系统的实际容量为(4096-18)\*512=2087936字节＝2039 KB＝1.99MB。

| 文件大小 | 占用的数据块            | 使用的索引结点块 |
| :------: | ----------------------- | ---------------- |
|  <=3KB   | <=6                     | 0                |
| <=131KB  | <=6+256=262             | 1                |
| <=2039KB | <=6+256+14*256+232=4078 | 17               |

假设每个文件大小平均分布，并把目录当成普通文件则平均占用数据块4078/2=2039个,平均使用索引结点块为：${3*0+(131-3)*1+(2039-131)*17} \over {2039}  $ $=16$个

则硬盘空间利用率为$2039\over2039+16$$=99.22\%$

则文件系统容量大约为$(4096-1)*512*99.22\%=2080214$字节$=2031.4KB=1.98MB$

### 5.索引结点表

由于每个索引结点大小为64个字节，最多有512\*8=4096个索引结点。故索引结点表的大小为64\*4096=256KB，512个块。为了和ext2保持一致，索引结点从1开始计数，0表示NULL。数据块则从0开始计数。 

### 6.模拟文件系统的“硬盘”数据结构

基于以上若干定义，得到模拟文件系统的“硬盘”数据结构：

![image-20231123184211430](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20231123184211430.png)

整个模拟文件系统所需要的“硬盘”空间为1+1+1+512+4096=4611个块。共计4611\*512bytes=2,360,832字节＝2305.5KB＝2.25MB。  其中，数据容量为1.99MB。最多可容纳的文件数目为4096-17=4079个。每个文件占用的数据空间最小为512字节，即一个块大小。

### 7.目录与文件

与ext2相同，目录作为特殊的文件来处理。将第1个索引结点指向根目录。根目录的索引结点中直接索引域指向数据块0。

目录体的数据结构与ext2基本相同，唯一的区别在于索引节点号用16位来表示： 

具体数据结构定义为：

```c
struct ext2_dir_entry { 
    _u16      inode;	    //索引节点号
    _u16      rec_len;	    //目录项长度    7~261 Byte
    _u8	      name_len;     //文件名长度
    _u8	      file_type;    //文件类型(1:普通文件，2:目录…)
    char	  name[EXT2_NAME_LEN];    //文件名
    char      authority;
}; 
```

当文件系统在初始化时，根目录的数据块（即数据块1）将被初始化。其所包含的所有索引节点号以及目录项长度域将被置0。当文件被删除时，其所在目录项长度不变，索引节点号将被置0。

当新建一个文件时，程序将从目录的数据块查找索引节点号为0的目录项，并检查其长度是否够用。是，则分配给该文件，否则继续查找，直到找到长度够用，或者是长度为0（即未被使用过）的地址，为文件建立目录项。 

当建立的是一个目录时，将其所分配到的索引结点所指向的数据块清空。并且自动写入两个特殊的目录项。一个是当前目录“.”,其索引结点即指向本身的数据块。另一个是上一级目录“..”，其索引结点指向上一级目录的数据块。例如，/root目录。其索引结点号为1。并且，第1个数据块存放着该目录的目录项。/root目录在文件系统初始化时自动生成。同时，在目录项中自动生成以下两项 

| inode | rec_len | name_len | file_type | name |      |      |
| ----- | ------- | -------- | --------- | ---- | ---- | ---- |
| 1     | 8       | 1        | 2         | .    | \0   |      |
| 1     | 9       | 2        | 2         | .    | .    | \0   |

### 8文件类型

| 文件类型号 | 描述       |
| ---------- | ---------- |
| 0          | 未知       |
| 1          | 普通文件   |
| 2          | 目录       |
| 3          | 字符设备   |
| 4          | 块设备     |
| 5          | 管道(Pipe) |
| 6          | 套接字     |
| 7          | 符号指针   |

### 9模拟文件系统的操作

![image-20231124165148805](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20231124165148805.png)

为了实现这些操作，内存中也必须有相应的数据结构。首先，内存中应当定义一个“当前目录”的数据结构，用来存放“当前目录”的索引结点号。此外，内存中还应当有一个“文件打开表”的数据结构。包括，打开文件ID，索引结点号。两个域。文件打开表应当是一个数组，数组的元组即允许同时打开的文件个数。 

### 10“存储空间”的管理

+ 这里涉及到模拟文件系统的5个底层操作：索引结点的分配与释放、数据块的分配与释放以及数据块的寻址。
+ 这些操作将采用ext2基本相同的方法实现。区别在于：Ext2中对superblock的操作将变成对组描述符的操作。此外，数据块在分配时不采取预先分配策略。查找空闲块的方法可采用从某个起始点开始线性查找。

### 11程序结构 

**初始化模拟文件系统** 

+ 在已有的文件系统的基础上建立一个大小为FS_SPACE=2,360,832字节(即2.25MB)的文件FS.txt，这个文件即用来模拟硬盘。以后，文件系统的所有操作，均通过读写这个文件实现。并且，完全模拟硬盘读写方式，一次读取1个块，即512字节。即使只有1个字节的修改，也通过读写一个数据块来实现。
+ 常驻内存的数据结构也被初始化。  

**文件系统级（底层）函数及其子函数**

 这些函数完成了所有文件系统底层的操作封装。并为上层即命令层提供服务。该层实现了所有对文件系统“硬盘”的块操作功能。例如：分配和回收索引结点与数据块，索引结点的读取与写入，数据块的读取与写入，索引结点及数据块位图的设置，组描述符的修改，多级索引的实现等。 

**命令层函数** 

文件系统所支持的命令及其功能在这一层实现。一共实现11个命令：

dir,mkdir,rmdir,create,delete,cd,attrib, open,close,read,write。为了实现这些命令，本层使用底层所提供的服务。

**用户接口层** 

主要功能是接收及识别用户命令，词法分析，提取命令及参数。组织调用命令层对应的命令实现相应功能。本层实际上是一个基于命令层基础上的shell。为了完善接口的功能，shell程序中增加了一些附加命令。这些命令无需调用文件系统级函数。这些附加命令有：quite命令退出程序，format命令重新建立文件系统。

### 12各层函数列表

**初始化文件系统**  

+ initialize_disk()	 /*建立文件系统*/
+ initialize_memory()	 /*初始化文件系统的内存数据*/ 

**底层** 

+ update_group_desc() /*将内存中的组描述符更新到"硬盘".*/
+ reload_group_desc() /*载入可能已更新的组描述符*/	
+ load_inode_entry()  /*载入特定的索引结点*/
+ update_inode_entry() /*更新特定的索引结点*/
+ load_block_entry() /*载入特定的数据块*/
+ update_block_entry()	/*更新特定的数据块*/
+ update_inode_i_block() /*根据多级索引机制更新索引结点的数据块信息域*/
+ ext2_new_inode() /*分配一个新的索引结点*/
+ ext2_alloc_block() /*分配一个新的数据块*/
+ ext2_free_inode() /*释放特定的索引结点*/
+ ext2_free_block_bitmap() /*释放特定块号的数据块位图*/
+ ext2_free_blocks()	/*释放特定文件的所有数据块*/
+ search_filename()	/*在当前目录中查找文件*/
+ test_fd()          /*检测文件打开ID(fd)是否有效*/

**命令层** 

+ dir()			/*无参数*/	
+ mkdir()			/*filename*/	
+ rmdir()			/*filename*/	
+ create()			/*filename*/	
+ delete_()			/*filename*/	
+ cd()			/*filename*/	
+ attrib()			/*filename，rw*/	
+ open()			/*filename*/	
+ close()			/*fd*/
+ read()			/*fd*/
+ write()			/*fd，source*/	

**用户接口层及附加命令** 

+ shell()		/*启动用户接口*/
+ format()		/*重新建立文件系统,无参数*/
+ quit()		/*退出shell(),无参数*/ 

**常驻内存的数据结构释意** 

+ unsigned short fopen_table[16] ; /*文件打开表，最多可以同时打开16个文件*/
+ unsigned short last_alloc_inode; /*上次分配的索引结点号*/
+ unsigned short last_alloc_block; /*上次分配的数据块号*/
+ unsigned short current_dir ;  /*当前目录(索引结点）*/
+ char current_path[256];   	 /*当前路径(字符串) */*
+ struct ext2_group_desc;	 /*组描述符*/ 



```c
    char ctable[16][10] = { "create", "delete", "cd", "close", "read", "write", "password", "format","exit","login","logout","dir","mkdir","rmdir","attrib","open"}; 
```

# 操作

> 0	create （filename）创建文件
>
> 1	delete  （filename）删除文件
>
> 2	cd	（dirname）	改变目录
>
> 3	close	（filename）	关闭文件
>
> 4	read	（filename）	读取文件
>
> 5	write	（filename）	写入文件
>
> 6	password	修改密码
>
> 7	format	格式化文件系统
>
> 8	exit	关闭文件系统
>
> 9	login	登录文件系统，但默认显示还未退出
>
> 10	logout	退出文件系统
>
> 11	dir	显示当前目录
>
> 12	mkdir	（filename）新建文件夹
>
> 13	rmdir	（filename） 删除文件夹
>
> 14	attrib （ilename authority）	修改filename文件的权限 （rw、r、w）
>
> 15	open	（filename） 打开文件
>
> 

1启动

![image-20231128161732504](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20231128161732504.png)

2新建文件操作

![](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20231128161926532.png)

3对于文件的读写

![image-20231128162111063](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20231128162111063.png)

4对于文件的删除

![image-20231128162234689](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20231128162234689.png)

5修改文件的读写权限

![image-20231128162458910](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20231128162458910.png)

6对文件夹的创建和删除

![image-20231128162607792](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20231128162607792.png)

7 cd命令

![image-20231128162702692](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20231128162702692.png)

8password命令

> 初始密码为123，可以修改，在修改时需要先输入旧密码，之后输入两次新密码，若两次新密码一致，则可以修改，否则需重新输入新密码。
>
> 在任何需要输入密码的情况下，用户输入的密码不会回显，并且具有回删的功能(需要现场展示)

![image-20231128163152365](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20231128163152365.png)

9login和logout命令展示

![image-20231128164552636](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20231128164552636.png)

10format和exit命令展示

![image-20231128164653978](https://gitee.com/du-jianyu1012/img/raw/master/picture/image-20231128164653978.png)





# **问题**

3fseek

fseek() 用于将与给定文件相关的文件指针移动到特定位置。

```c
int fseek(FILE *pointer, long int offset, int position);
pointer是指向 FILE 对象的指针，用于标识数据流.
offset是从位置开始偏移的字节数
position 它是增加偏移量的位置。位置定义了文件指针需要移动的位置。它有三个值
    SEEK_END	表示文件结束。	
    SEEK_SET	表示文件开始
    SEEK_CUR	表示文件指针的当前位置。
fseek运行成功，则文件指针指向 (positon+offset)的位置。运行失败，则不发生变化
```



4fopen

```c
FILE *fopen(const char *file_name, const char *mode_of_operation);
该方法接受两个字符指针类型的参数：
返回打开的特定文件的指针
file_name：C 字符串类型，接受需要打开的文件名。
mode_of_operation：操作模式：也是 C 字符串类型，指文件访问模式。
```

w+（如果文件存在，其内容将被覆盖。如果文件不存在，则创建一个新文件。如果无法打开文件，则返回 NULL。w+创建的新文件可以读，但是w不可以）	r+（读写）	r（只读）

5fread

```c
从文件流中读取给定数量的数据。函数 fread() 从文件流中读取给定数量的特定大小的元素，并将其存储在缓冲存储器中。fread() 函数读取的总字节数是读取的元素个数乘以每个元素的字节大小。
size_t fread(void * buffer, size_t size, size_t count, FILE * stream);
buffer：指的是存储读取数据的缓冲区内存块指针。
size：大小：指每个元素的大小（字节）。
count：计数：指要读取的元素计数。
stream：文件流指针。
```



6fwrite

```c
size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)
const void *ptr : 指针指向要写出数据的内存首地址 ;

size_t size : 要写出数据的 基本单元 的字节大小 , 写出单位的大小 ;

size_t nmemb : 要写出数据的 基本单元 的个数 ;

FILE *stream : 打开的文件指针 ;
```





1.为了实现密码和文件打开表等功能，对PPT中给出的数据结构进行了扩充修改。

2.在实现过程中，将头文件，全局变量，函数实现分开实现，使用预处理命令进行条件编译(一开始会报错，后面上网搜索以后发现问题)

3.底层函数实现，如系统初始化 format函数，删除和创建文件操作在实现时遇到很大困难，通过参考实验流程图以及上网查阅资料解决

4.在实现对文件的操作时，需要用到fseek、fread、fwrite、fopen、fclose等函数，一开始不了解，通过查阅资料后了解了函数的参数、输出结果、各个参数的含义。

5.调试代码遇到的问题：

1)关于缓冲区的问题 clearbuffer 解决

在实现logout之后重新login的过程时，logout之后，输入login则重新登录，由于在用scanf读取输出时，没有将回车符读走，所以重新定义了clearBuffer函数来情况缓存区。之后成功实现了login logout

2)回退键无效

对于login、password等函数，想实现的功能时，输入时隐藏，同时具有回退的功能。将输入设置为*很容易实现，但是添加回退功能时遇到困难。原因是getch函数的头文件conio.h在Linux中没有，通过查找资料，找到了一个在Linux中类似的实现为

```c
//in windows
#include<stdio.h>
#include<conio.h>
int mian(){
	char c;
	printf("input a char:");
	c=getch();
	printf("You have inputed:%c \n",c);
	return 0;
}

//in linux
#include<stdio.h>
int main(){
	char c;
	printf("Input a char:");
	system("stty -echo");	//不显示输入内容
	c=getchar();
	system("stty echo");
	printf("You have inputed:%c \n",c);
	return 0;
}
```

